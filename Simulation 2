---
title: "Simulation Study code"
author: "BALD"
date: "2025-07-22"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


gen data
# RUN THIS BEFORE MAIN
Generate data
```{r}
genData <- function(n, m, p, range, smooth, sige, gamma, sigre) {
  ### Functions
  
  library(fields)
  library(plyr)
  library(boot)
  library(purrr)
  library(dplyr)
  library(magrittr)
  
  
  genX <- function(m,range=0.1,smoothness=2){
    # m has to be a power of 2!
    library(spectralGP)
    capture.output(X  <- gp(c(m,m),matern.specdens,c(range,smoothness)))
    simulate(X)
    X <- matrix(X$process,m,m)
    return(as.vector(X))
  }
  
  expit <- function(x){1/(1+exp(-x))}
  
  create_locations <- function(n=32,m=4){
    s <- expand.grid(1:n,1:n)
    b <- ceiling(s/m)
    g <- b[,1] + round(n/m)*(b[,2]-1)
    return(list(s=s,g=g))}
  
  # Assign spatial locations
  locs   <- create_locations(32,4)
  s      <- locs$s
  g      <- locs$g
  
  
  # Generate X
  X    <- Xbar <- NULL
  for(j in 1:p){
    x    <- genX(n,range,smooth)
    xbar <- aggregate(x,by=list(g),mean,simplify=TRUE)[,2]
    X    <- cbind(X,x)
    Xbar <- cbind(Xbar,xbar)
  }
  
  # Generate D
  pD     <- expit(0.04 * (10 * sin(Xbar[,1] * Xbar[,2]) + 20 * (Xbar[,3] - 0.5)^2 + 10 * Xbar[,4] + 5 * Xbar[,5]))
  Dbar   <- rbinom(length(pD),1,pD)
  D      <- Dbar[g]
  
  # Generate Y
  alpha  <- rnorm(max(g),0,sigre)
  Y0     <- rnorm(n^2, X[,1] + 3*X[,4] + alpha[g], sige)
  Y1     <- rnorm(n^2, X[,1] + 3*X[,4] + 5*X[,5] + X[,1] + gamma*D + alpha[g], sige)
  
  #Latitude and Longitude
  longitude_m <- matrix(rep(seq(0, 1, length.out = n), each = n), nrow = n, ncol = n, byrow = FALSE)
  latitude_m <- matrix(rep(seq(0, 1, length.out = n), times = n), nrow = n, ncol = n)
  longitude_v <- as.vector(longitude_m)
  latitude_v <- as.vector(latitude_m)
  
  # Generating Block ID  
  my_vec1 <- rep(c(1,2,3,4,5,6,7,8), 4, each = 4)
  my_vec2 <- rep(c(9,10,11,12,13,14,15,16), 4, each = 4)
  my_vec3 <- rep(c(17,18,19,20,21,22,23,24), 4, each = 4)
  my_vec4 <- rep(c(25,26,27,28,29,30,31,32), 4, each = 4)
  my_vec5 <- rep(c(33,34,35,36,37,38,39,40), 4, each = 4)
  my_vec6 <- rep(c(41,42,43,44,45,46,47,48), 4, each = 4)
  my_vec7 <- rep(c(49,50,51,52,53,54,55,56), 4, each = 4)
  my_vec8 <- rep(c(57,58,59,60,61,62,63,64), 4, each = 4)
  Block_ID <- c(my_vec1, my_vec2, my_vec3, my_vec4, my_vec5, my_vec6, my_vec7, my_vec8)
  
  
  # make into data frame
  df <- data.frame(cbind(X, D, Y0, Y1, longitude_v, latitude_v, Block_ID))
  df <- df %>%
    rename("V1" = "x", "V2"  = "x.1", "V3" = "x.2", "V4" = "x.3", "V5" = "x.4", "dat1.D" = "D", "dat1.Y0" = "Y0", "dat1.Y1" = "Y1", "dat1.ID" = "Block_ID")
  
  return(df)
}
```





ML methods

```{r}
library(estimatr)
library(dbarts)
library(BART)
library(caret)
library(magrittr)


# OLS
# number of pixels
OLS <- function (df, nrow, ncol) {
  n <- nrow*ncol
  t <- c(rep(0, n), rep(1, n))
  c_df <- rbind(df, df)
  colnames(c_df) <- c("x1", "x2", "x3", "x4", "x5", "D", "Y0", "Y1", "long", "lat", "ID")
  regress_OLS <- lm(c(df[,7], df[,8]) ~ c_df[,1] + c_df[,2] + c_df[,3]
                    + t + c_df[,6] + t*c_df[,6])
  regress_robust_OLS <- lm_robust(c(df[,7], df[,8]) ~ c_df[,1] + c_df[,2] +  c_df[,3]
                                  + t + c_df[,6] + t*c_df[,6])
  summary_OLS <- summary(regress_robust_OLS)
  return(regress_robust_OLS)
}


#################################################
# DID
# number of pixels
DID <- function (df, nrow, ncol) {
  n <- nrow*ncol
  
  # DBar Creation
  D_m <- matrix(df[,6], 32, 32)
  loc_D <- matrix(NA, 32, 32)
  
  for (i in 1:nrow(D_m)) {
    for (j in 1:ncol(D_m)) {
      # get surroundings (rook)
      # consider all cases
      if (i == 1) {
        if (j == 1) {
          neighbors <- c(D_m[i+1, j], D_m[i, j+1])
        }
        else if (j == 32) {
          neighbors <- c(D_m[i+1, j], D_m[i, j-1])
        }
        else {
          neighbors <- c(D_m[i+1, j], D_m[i, j+1], D_m[i, j-1])
        }
      }
      else if (i == 32) {
        if (j == 1) {
          neighbors <- c(D_m[i-1, j], D_m[i, j+1])
        }
        else if (j == 32) {
          neighbors <- c(D_m[i-1, j], D_m[i, j-1])
        }
        else {
          neighbors <- c(D_m[i-1, j], D_m[i, j+1], D_m[i, j-1])
        }      
      }
      else {
        if (j == 1) {
          neighbors <- c(D_m[i+1, j], D_m[i-1, j], D_m[i, j+1])
        }
        else if (j == 32) {
          neighbors <- c(D_m[i+1, j], D_m[i-1, j], D_m[i, j-1])
        }
        else {
          neighbors <- c(D_m[i+1, j], D_m[i-1, j], D_m[i, j+1], D_m[i, j-1])
        }
      }
      loc_D[i,j] <- mean(na.omit(neighbors))  
    }
  }
  loc_D_v <- as.vector(loc_D)
  
  # regression
  t <- c(rep(0, n), rep(1, n))
  c_df <- rbind(df, df)
  regress_DID <- lm(c(df[,7], df[,8]) ~ c_df[,1] + c_df[,2] + c_df[,3]
                    + t + c_df[,6] + c(loc_D_v, loc_D_v) + 
                      t*c_df[,6] + t*c(loc_D_v, loc_D_v))
  regress_robust_DID <- lm_robust(c(df[,7], df[,8]) ~ c_df[,1] + c_df[,2] + c_df[,3] 
                                  + t + c_df[,6] + c(loc_D_v, loc_D_v) + 
                                    t*c_df[,6] + t*c(loc_D_v, loc_D_v))
  return(regress_robust_DID)
}





##############################################################

##              NO  RANDOM  EFFECTS

##############################################################




# DML function for simulation study (without crossfitting)
DML_nocross <- function(df, nrow, ncol) {
  
# number of pixels
  n <- nrow*ncol
  
  # BART f0
  x <- df[,c(1:3, 9, 10)]
  y <- df[,7]
  bart_fitY0 <- wbart(x.train = x, y.train = y)
  
  # BART f1
  y <- df[,8]
  bart_fitY1 <- wbart(x.train = x, y.train = y)
  
  # BART g
  y <- df[,6]
  bart_fit_g <- pbart(x.train = x, y.train = y)
  predicted_g <- predict(bart_fit_g, x)
  
  # residuals
  R_Y0 <- df[,7] - bart_fitY0$yhat.train.mean
  R_Y1 <- df[,8] - bart_fitY1$yhat.train.mean
  R_D <- df[,6] - predicted_g$prob.test.mean
  
  # calculate local mean
  R_D_m <- matrix(R_D, nrow, ncol)
  localR_D_m <- matrix(NA, nrow, ncol)
  for (i in 1:nrow) {
    for (j in 1:ncol) {
      # get surroundings (rook)
      # consider all cases
      if (i == 1) {
        if (j == 1) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j+1])
        }
        else if (j == ncol) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j+1], R_D_m[i, j-1])
        }
      }
      else if (i == nrow) {
        if (j == 1) {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j+1])
        }
        else if (j == ncol) {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j+1], R_D_m[i, j-1])
        }      
      }
      else {
        if (j == 1) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], R_D_m[i, j+1])
        }
        else if (j == ncol) {
        neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], 
                         R_D_m[i, j+1], R_D_m[i, j-1])
        }
      }
    localR_D_m[i,j] <- mean(na.omit(neighbors))   
    }
  }
  localR_D <- as.vector(localR_D_m)

  # regression
  t <- c(rep(0, n), rep(1, n))
  regress_DML_noCross <- lm(c(R_Y0, R_Y1) ~ t + c(R_D, R_D) + c(localR_D, localR_D) + t*c(R_D, R_D) + t*c(localR_D, localR_D))
  regress_robust_DML_noCross <- lm_robust(c(R_Y0, R_Y1) ~ t + c(R_D, R_D) + c(localR_D, localR_D) + t*c(R_D, R_D) + t*c(localR_D, localR_D))
  return(list(regress_DML_noCross, regress_robust_DML_noCross))
}



###########################################
#DML w crossfitting by pixel
DML_bypixel <- function(df, nrow, ncol) {

    #This is a Wendland Kernel 
  basis_wend <- function(s,u,theta){
    d1 <- rdist(s,u)/theta
    # Wendland basis function from Nychka  
    mat1 <- apply(d1,c(1,2),function(x){
      if(x <= 1){
        return( (1-x)^6 * (36*x^2 +18*x + 3)/3)
      }else{
        return(0)
      }
    })
    
    return(mat1)
  }
  
  m <- 32
  n <- m^2
  # s is spatial locations
  s <- expand.grid((1:m)/(m+1),(1:m)/(m+1))
  l <- 10
  L <- l^2
  # knot points
  u     <- expand.grid(seq(0,1,length=l),seq(0,1,length=l))
  #bandwidth parameter 2.5
  Z <- basis_wend(s,u,2.5/l)
  df_w <- cbind(df, Z)
  
  #BART f0
  x <- df_w[,c(1:3, 9, 10, 12:ncol(df_w))]
  y <- df_w[,7]
  
  # split data into 10 folds
  folds <- createFolds(y, k = 10)
  
  # initialize placeholder for predictions
  predict_Y0 <- rep(NA, n)
  
  # crossfitting Y0
  for (fold in seq_along(folds)) {
    
    # this is the training data set
    train_idx <- setdiff(seq_len(n), folds[[fold]])
    
    # ith fold
    test_idx <- folds[[fold]]
    
    # storing the predicted bart data into the placeholder vectors
    bart_preds <- wbart(x.train = x[train_idx,], y.train = y[train_idx], x.test = x[test_idx,])
    predict_Y0[test_idx] <- bart_preds$yhat.test.mean
  }
  
  #BART f1
  y <- df_w[,8]
  
  # split data into 10 folds
  folds <- createFolds(y, k = 10)
  
  # initialize placeholder for predictions
  predict_Y1 <- rep(NA, n)
  
  # crossfitting Y1
  for (fold in seq_along(folds)) {
    
    # this is the training data set
    train_idx <- setdiff(seq_len(n), folds[[fold]])
    
    # ith fold
    test_idx <- folds[[fold]]
    
    
    # storing the predicted bart data into the placeholder vectors
    bart_preds <- wbart(x.train = x[train_idx,], y.train = y[train_idx], x.test = x[test_idx,])
    predict_Y1[test_idx] <- bart_preds$yhat.test.mean
  }
  
  #BART g
  
  y <- df_w[,6]
  x <- df_w[,c(1:3, 9, 10, 12:ncol(df_w))]
  
  # split data into 10 folds
  folds <- createFolds(y, k = 10)
  
  # initialize placeholder for predictions
  predict_D <- rep(NA, n)
  
  # crossfitting D
  for (fold in seq_along(folds)) {
    
    # this is the training data set
    train_idx <- setdiff(seq_len(n), folds[[fold]])
    
    # ith fold
    test_idx <- folds[[fold]]
    
    # storing the predicted bart data into the placeholder vectors
    bart_preds <- pbart(x.train = x[train_idx,], y.train = y[train_idx], x.test = x[test_idx,])
    predict_D[test_idx] <- bart_preds$prob.test.mean
  }
  
  
  # residuals
  R_Y0 <- df[,7] - predict_Y0
  R_Y1 <- df[,8] - predict_Y1
  R_D <- df[,6] - predict_D
  
  # calculate local mean
  R_D_m <- matrix(R_D, nrow, ncol)
  localR_D_m <- matrix(NA, nrow, ncol)
  for (i in 1:nrow) {
    for (j in 1:ncol) {
      # get surroundings (rook)
      # consider all cases
      if (i == 1) {
        if (j == 1) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j+1])
        }
        else if (j == ncol) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j+1], R_D_m[i, j-1])
        }
      }
      else if (i == nrow) {
        if (j == 1) {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j+1])
        }
        else if (j == ncol) {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j+1], R_D_m[i, j-1])
        }      
      }
      else {
        if (j == 1) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], R_D_m[i, j+1])
        }
        else if (j == ncol) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], 
                         R_D_m[i, j+1], R_D_m[i, j-1])
        }
      }
      localR_D_m[i,j] <- mean(na.omit(neighbors))   
    }
  }
  localR_D <- as.vector(localR_D_m)
  
  # regression
  t <- c(rep(0, n), rep(1, n))
  regress_DML <- lm(c(R_Y0, R_Y1) ~ t + c(R_D, R_D) + c(localR_D, localR_D) + t*c(R_D, R_D) + t*c(localR_D, localR_D))
  regress_robust_DML <- lm_robust(c(R_Y0, R_Y1) ~ t + c(R_D, R_D) + c(localR_D, localR_D) + t*c(R_D, R_D) + t*c(localR_D, localR_D))
  summary(regress_DML)
  return(list(regress_DML, regress_robust_DML))
}



###########################
###########################
###########################


DML_byblock <- function(df, nrow, ncol) {
  
  library(caret)
  
  #This is a Wendland Kernel 
  basis_wend <- function(s,u,theta){
    
    d1 <- rdist(s,u)/theta
    
    # Wendland basis function from Nychka  
    mat1 <- apply(d1,c(1,2),function(x){
      if(x <= 1){
        return( (1-x)^6 * (36*x^2 +18*x + 3)/3)
      }else{
        return(0)
      }
    })
    
    return(mat1)
    
    
  }
  m <- 32
  n <- m^2
  # s is spatial locations
  s <- expand.grid((1:m)/(m+1),(1:m)/(m+1))
  l     <- 10
  L     <- l^2
  # knot points
  u     <- expand.grid(seq(0,1,length=l),seq(0,1,length=l))
  #bandwidth parameter 2.5
  Z     <- basis_wend(s,u,2.5/l)
  
  df_w <- cbind(df, Z)
  #BART f0
  x <- df_w[,c(1:3, 9, 10, 12:ncol(df_w))]
  y <- df_w[,7]
  
  # split data into 10 folds
  folds <- createFolds(seq(1,64), k = 10)
  
  df2 <- cbind(seq(1024), df)
  
  current_fold <- data.frame(as.numeric(folds$Fold01))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold01."))
  folds$Fold01 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold02))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold02."))
  folds$Fold02 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold03))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold03."))
  folds$Fold03 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold04))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold04."))
  folds$Fold04 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold05))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold05."))
  folds$Fold05 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold06))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold06."))
  folds$Fold06 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold07))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold07."))
  folds$Fold07 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold08))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold08."))
  folds$Fold08 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold09))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold09."))
  folds$Fold09 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold10))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold10."))
  folds$Fold10 <- folds_df[,1]
  
  
  # initialize placeholder for predictions
  predict_Y0 <- rep(NA, n)
  
  # crossfitting Y0
  for (fold in seq_along(folds)) {
    
    # this is the training data set
    train_idx <- setdiff(seq_len(n), folds[[fold]])
    
    # ith fold
    test_idx <- folds[[fold]]
    
    # storing the predicted bart data into the placeholder vectors
    bart_preds <- wbart(x.train = x[train_idx,], y.train = y[train_idx], x.test = x[test_idx,])
    predict_Y0[test_idx] <- bart_preds$yhat.test.mean
  }
  
  #BART f1
  y <- df[,8]
  
  
  
  #Creating different folds
  
  folds <- createFolds(seq(1,64), k = 10)
  
  df2 <- cbind(seq(1024), df)
  
  current_fold <- data.frame(as.numeric(folds$Fold01))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold01."))
  folds$Fold01 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold02))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold02."))
  folds$Fold02 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold03))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold03."))
  folds$Fold03 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold04))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold04."))
  folds$Fold04 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold05))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold05."))
  folds$Fold05 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold06))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold06."))
  folds$Fold06 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold07))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold07."))
  folds$Fold07 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold08))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold08."))
  folds$Fold08 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold09))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold09."))
  folds$Fold09 <- folds_df[,1]
  
  current_fold <- data.frame(as.numeric(folds$Fold10))
  folds_df <- semi_join(df2, current_fold, by = join_by("dat1.ID" == "as.numeric.folds.Fold10."))
  folds$Fold10 <- folds_df[,1]
  
  
  # initialize placeholder for predictions
  predict_Y1 <- rep(NA, n)
  
  # crossfitting Y1
  for (fold in seq_along(folds)) {
    
    # this is the training data set
    train_idx <- setdiff(seq_len(n), folds[[fold]])
    
    # ith fold
    test_idx <- folds[[fold]]
    
    
    # storing the predicted bart data into the placeholder vectors
    bart_preds <- wbart(x.train = x[train_idx,], y.train = y[train_idx], x.test = x[test_idx,])
    predict_Y1[test_idx] <- bart_preds$yhat.test.mean
  }
  
  #BART g
  
  bart_d <-  df_w %>% 
    group_by (dat1.ID) %>%
    summarize_all(mean)
  
  
  y <- as.vector(bart_d[,7]$dat1.D)
  x <- data.frame(bart_d[,c(2:4, 9, 10, 12:ncol(bart_d))]) 
  
  
  # split data into 10 folds
  folds <- createFolds(y, k = 10)
  
  # initialize placeholder for predictions
  predict_D <- rep(NA, 64)
  
  # crossfitting D
  for (fold in seq_along(folds)) {
    
    # this is the training data set
    train_idx <- setdiff(seq_len(64), folds[[fold]])
    
    # ith fold
    test_idx <- folds[[fold]]
    
    # storing the predicted bart data into the placeholder vectors
    bart_preds <- pbart(x.train = x[train_idx,], y.train = y[train_idx], x.test = x[test_idx,])
    predict_D[test_idx] <- bart_preds$prob.test.mean
    
  }
  
  df_fit_d <- data.frame(seq(1, 64), predict_D)
  onecolumn_df <- data.frame(df[,11])
  new_dfit <- left_join(onecolumn_df, df_fit_d, by = c("df...11." = "seq.1..64."))
  predict_D <- new_dfit$predict_D
  
  # residuals
  R_Y0 <- df[,7] - predict_Y0
  R_Y1 <- df[,8] - predict_Y1
  R_D <- df[,6] - predict_D
  
  # calculate local mean
  R_D_m <- matrix(R_D, 32, 32)
  localR_D_m <- matrix(NA, 32, 32)
  for (i in 1:32) {
    for (j in 1:32) {
      # get surroundings (rook)
      # consider all cases
      if (i == 1) {
        if (j == 1) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j+1])
        }
        else if (j == 32) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j+1], R_D_m[i, j-1])
        }
      }
      else if (i == 32) {
        if (j == 1) {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j+1])
        }
        else if (j == 32) {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j+1], R_D_m[i, j-1])
        }      
      }
      else {
        if (j == 1) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], R_D_m[i, j+1])
        }
        else if (j == 32) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], 
                         R_D_m[i, j+1], R_D_m[i, j-1])
        }
      }
      localR_D_m[i,j] <- mean(na.omit(neighbors))   
    }
  }
  localR_D <- as.vector(localR_D_m)
  
  # regression
  library(lme4)
  t <- c(rep(0, n), rep(1, n))
  regress_DML <- lm(c(R_Y0, R_Y1) ~ t + c(R_D, R_D) + t*c(R_D, R_D))
  regress_robust_DML <- lm_robust(c(R_Y0, R_Y1) ~ t + c(R_D, R_D) + t*c(R_D, R_D))
  summary(regress_DML)
  summary(regress_robust_DML)
  return(list(regress_DML, regress_robust_DML))
}



################################################################


####################      INCLUDING RANDOM EFFECTS


################################################################


#Random Effects with wendland without crossfitting
RE_nocross <- function(df, nrow, ncol) {

  #This is a Wendland Kernel 
  basis_wend <- function(s,u,theta){
  
  d1 <- rdist(s,u)/theta

  # Wendland basis function from Nychka  
  mat1 <- apply(d1,c(1,2),function(x){
    if(x <= 1){
      return( (1-x)^6 * (36*x^2 +18*x + 3)/3)
    }else{
      return(0)
    }
  })
  
  return(mat1)

  
  }
    m <- 32
    n <- m^2
    # s is spatial locations
    s <- expand.grid((1:m)/(m+1),(1:m)/(m+1))
    l     <- 10
    L     <- l^2
    # knot points
    u     <- expand.grid(seq(0,1,length=l),seq(0,1,length=l))
    #bandwidth parameter 2.5
    Z     <- basis_wend(s,u,2.5/l)
    
    
  df_w <- cbind(df, Z)
  ID <- as.vector(df_w$dat1.ID)
  lat <- as.vector(df_w$latitude_v)
  long <- as.vector (df_w$longitude_v)
  x <- df_w[,c(1:3, 9:10, 12:ncol(df_w))]
  
  # wendland f0
  y <- df_w[,7]
  #ID <- df_w$dat1.ID
  
  df_w_f0 <- as.data.frame(x)
  df_w_f0$y <- y
  df_w_f0$ID <- ID
  df_w_f0$lat <- lat
  df_w_f0$long <- long
  wend_f0 <- y ~ . - ID #- lat - long
  names(df_w_f0) <- make.names(names(df_w_f0), unique = TRUE) #this is here to fix an error that you otherwise get
  
  #bart fit with wendland for f0
  wend_fitY0 <- rbart_vi(wend_f0, data = df_w_f0, group.by = df_w_f0$ID)
  
  
  
  # BART f1
  y <- df_w[,8]
  df_w_f1 <- as.data.frame(x)
  df_w_f1$y <- y
  df_w_f1$ID <- ID
  df_w_f1$lat <- lat
  df_w_f1$long <- long
  
  wend_f1 <- y ~ . - ID #- lat - long
  names(df_w_f1) <- make.names(names(df_w_f1), unique = TRUE) #this is here to fix an error that you otherwise get
  
  #bart fit with wendland for f1
  wend_fitY1 <- rbart_vi(wend_f1, data = df_w_f1, group.by = df_w_f1$ID)
  
  
  
  # BART g
    
  y <- df_w[,6] #CHECK  
  
  bart_fit_g <- pbart(x.train = x, y.train = y, x.test = x)
  predicted_g <-  bart_fit_g$prob.test.mean
  
  
  # residuals
  R_Y0 <- df_w[,7] - wend_fitY0$yhat.train.mean
  R_Y1 <- df_w[,8] - wend_fitY1$yhat.train.mean
  R_D <- df_w[,6] - predicted_g
  
  # calculate local mean
  R_D_m <- matrix(R_D, 32, 32)
  localR_D_m <- matrix(NA, 32, 32)
  for (i in 1:32) {
    for (j in 1:32) {
      # get surroundings (rook)
      # consider all cases
      if (i == 1) {
        if (j == 1) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j+1])
        }
        else if (j == 32) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j+1], R_D_m[i, j-1])
        }
      }
      else if (i == 32) {
        if (j == 1) {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j+1])
        }
        else if (j == 32) {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j+1], R_D_m[i, j-1])
        }      
      }
      else {
        if (j == 1) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], R_D_m[i, j+1])
        }
        else if (j == 32) {
        neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], 
                         R_D_m[i, j+1], R_D_m[i, j-1])
        }
      }
    localR_D_m[i,j] <- mean(na.omit(neighbors))   
    }
  }
  localR_D <- as.vector(localR_D_m)

  # regression
  t <- c(rep(0, n), rep(1, n))
  regress_DML_RE <- lm(c(R_Y0, R_Y1) ~ t + c(R_D, R_D) + t*c(R_D, R_D))
  regress_robust_DML_RE <- lm_robust(c(R_Y0, R_Y1) ~ t + c(R_D, R_D)  + t*c(R_D, R_D))
  summary(regress_DML_RE)
  summary(regress_robust_DML_RE)
  return(list(regress_DML_RE, regress_robust_DML_RE))
}



#####################################



#####################################


# Random effects Wendland with Crossfitting, WITH LAT/LONG
RE_bypixel <- function(df, nrow, ncol) {

  #This is a Wendland Kernel 
  basis_wend <- function(s,u,theta){
    d1 <- rdist(s,u)/theta
    # Wendland basis function from Nychka  
    mat1 <- apply(d1,c(1,2),function(x){
      if(x <= 1){
        return( (1-x)^6 * (36*x^2 +18*x + 3)/3)
      }else{
        return(0)
      }
    })
    
    return(mat1)
  }
  
  m <- 32
  n <- m^2
  # s is spatial locations
  s <- expand.grid((1:m)/(m+1),(1:m)/(m+1))
  l <- 10
  L <- l^2
  # knot points
  u     <- expand.grid(seq(0,1,length=l),seq(0,1,length=l))
  #bandwidth parameter 2.5
  Z <- basis_wend(s,u,2.5/l)
  
  df_w <- cbind(df, Z)
  ID <- as.vector(df_w$dat1.ID)
  lat <- as.vector(df_w$latitude_v)
  long <- as.vector(df_w$longitude_v)
  x <- df_w[,c(1:3, 9:10, 12:ncol(df_w))]
  
  
  #BART f0
  y <- df_w[,7]
  crossdf_w_f0 <- as.data.frame(x)
  crossdf_w_f0$y <- y
  crossdf_w_f0$ID <- ID
  crossdf_w_f0$lat <- lat
  crossdf_w_f0$long <- long
  
  # split data into 10 folds
  folds <- createFolds(y, k = 10)
  # initialize placeholder for predictions
  predict_Y0 <- rep(NA, n)
  
  suppressWarnings({ 
    # crossfitting Y0
    for (fold in seq_along(folds)) {
      
      # this is the training data set
      train_idx <- setdiff(seq_len(n), folds[[fold]])
      # ith fold
      test_idx <- folds[[fold]]
      
      #dataframes for training and testing
      train_df <- cbind(x[train_idx, ], y = y[train_idx], ID = crossdf_w_f0$ID[train_idx])
      test_df <- cbind(x[test_idx, ], y = y[test_idx], ID = crossdf_w_f0$ID[test_idx])
      
      names(train_df) <- make.names(names(train_df), unique = TRUE)
      names(test_df) <- make.names(names(test_df), unique = TRUE)
      # bart model
      crossfit_Y0 <- rbart_vi(y ~ . - ID, data = train_df, group.by = train_df$ID)
      matrix_Y0 <- predict(crossfit_Y0, newdata = test_df, group.by = test_df$ID)
      predict_Y0[test_idx] <- matrix_Y0
    }
    
  })
  
  
  #BART f1
  y <- df_w[,8]
  crossdf_w_f1 <- as.data.frame(x)
  crossdf_w_f1$y <- y
  crossdf_w_f1$ID <- ID
  crossdf_w_f1$lat <- lat
  crossdf_w_f1$long <- long
  
  # split data into 10 folds
  folds <- createFolds(y, k = 10)
  # initialize placeholder for predictions
  predict_Y1 <- rep(NA, n)
  
  suppressWarnings({ 
    # crossfitting Y0
    for (fold in seq_along(folds)) {
      
      # this is the training data set
      train_idx <- setdiff(seq_len(n), folds[[fold]])
      # ith fold
      test_idx <- folds[[fold]]
      
      #dataframes for training and testing
      train_df <- cbind(x[train_idx, ], y = y[train_idx], ID = crossdf_w_f1$ID[train_idx])
      test_df <- cbind(x[test_idx, ], y = y[test_idx], ID = crossdf_w_f1$ID[test_idx])
      
      names(train_df) <- make.names(names(train_df), unique = TRUE)
      names(test_df) <- make.names(names(test_df), unique = TRUE)
      # bart model
      crossfit_Y1 <- rbart_vi(y ~ . - ID, data = train_df, group.by = train_df$ID)
      matrix_Y1 <- predict(crossfit_Y1, newdata = test_df, group.by = test_df$ID)
      predict_Y1[test_idx] <- matrix_Y1 #changed this, used to not have colMeans()
    }
  })
  
  
  #BART g
  y <- df[,6]
  
  crossdf_w_g <- as.data.frame(x)
  crossdf_w_g$y <- y
  crossdf_w_g$ID <- ID
  
  # split data into 10 folds
  folds <- createFolds(y, k = 10)
  
  # initialize placeholder for predictions
  predict_D <- rep(NA, n)
  
  # crossfitting D
  for (fold in seq_along(folds)) {
    
    # this is the training data set
    train_idx <- setdiff(seq_len(n), folds[[fold]])
    # ith fold
    test_idx <- folds[[fold]]
    
    # storing the predicted bart data into the placeholder vectors
    wend_cross_g <- pbart(x.train = x[train_idx,], y.train=y[train_idx], x.test = x[test_idx,])
    predict_D[test_idx] <- wend_cross_g$prob.test.mean
    
  }
  
  # residuals
  R_Y0 <- df[,7] - predict_Y0
  R_Y1 <- df[,8] - predict_Y1
  R_D <- df[,6] - predict_D
  
  # calculate local mean
  R_D_m <- matrix(R_D, 32, 32)
  localR_D_m <- matrix(NA, 32, 32)
  for (i in 1:32) {
    for (j in 1:32) {
      # get surroundings (rook)
      # consider all cases
      if (i == 1) {
        if (j == 1) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j+1])
        }
        else if (j == 32) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j+1], R_D_m[i, j-1])
        }
      }
      else if (i == 32) {
        if (j == 1) {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j+1])
        }
        else if (j == 32) {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j+1], R_D_m[i, j-1])
        }      
      }
      else {
        if (j == 1) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], R_D_m[i, j+1])
        }
        else if (j == 32) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], 
                         R_D_m[i, j+1], R_D_m[i, j-1])
        }
      }
      localR_D_m[i,j] <- mean(na.omit(neighbors))   
    }
  }
  localR_D <- as.vector(localR_D_m)
  
  # regression
  library(lme4)
  t <- c(rep(0, n), rep(1, n))
  regress_DML <- lm(c(R_Y0, R_Y1) ~ t + c(R_D, R_D) + t*c(R_D, R_D))
  regress_robust_DML <- lm_robust(c(R_Y0, R_Y1) ~ t + c(R_D, R_D) + t*c(R_D, R_D))
  summary(regress_DML)
  summary(regress_robust_DML)
  return(list(regress_DML, regress_robust_DML))
  
}




########################################################



#########################################################


#Wendland with crossfitting by block
RE_byblock  <- function(df, nrow, ncol) {
  
  
  #This is a Wendland Kernel 
  basis_wend <- function(s,u,theta){
    
    d1 <- rdist(s,u)/theta
    
    # Wendland basis function from Nychka  
    mat1 <- apply(d1,c(1,2),function(x){
      if(x <= 1){
        return( (1-x)^6 * (36*x^2 +18*x + 3)/3)
      }else{
        return(0)
      }
    })
    
    return(mat1)
    
    
  }
  
  m <- 32
  n <- m^2
  # s is spatial locations
  s <- expand.grid((1:m)/(m+1),(1:m)/(m+1))
  l     <- 10
  L     <- l^2
  # knot points
  u     <- expand.grid(seq(0,1,length=l),seq(0,1,length=l))
  #bandwidth parameter 2.5
  Z     <- basis_wend(s,u,2.5/l)
  
  
  df_w <- cbind(df, Z)
  ID <- as.vector(df_w$dat1.ID)
  lat <- as.vector(df_w$latitude_v)
  long <- as.vector (df_w$longitude_v)
  x <- df_w[,c(1:3, 9:10, 12:ncol(df_w))] #this includes lat and long
  
  
  #BART f0
  y <- df_w[,7]
  df_w_f0 <- as.data.frame(x)
  df_w_f0$y <- y
  df_w_f0$ID <- ID
  df_w_f0$lat <- lat
  df_w_f0$long <- long
  wend_f0 <- y ~ . - ID 
  
  # split data into 10 folds
  folds <- createFolds(y, k = 10)
  
  
  
  # initialize placeholder for predictions
  predict_Y0 <- rep(NA, n)
  
  suppressWarnings({ 
    # crossfitting Y0
    for (fold in seq_along(folds)) {
      
      # this is the training data set
      train_idx <- setdiff(seq_len(n), folds[[fold]])
      # ith fold
      test_idx <- folds[[fold]]
      
      #dataframes for training and testing
      train_df <- cbind(x[train_idx, ], y = y[train_idx], ID = df_w_f0$ID[train_idx])
      
      test_df <- cbind(x[test_idx, ], y = y[test_idx], ID = df_w_f0$ID[test_idx])
      
      names(train_df) <- make.names(names(train_df), unique = TRUE)
      names(test_df) <- make.names(names(test_df), unique = TRUE)
      # bart model
      crossfit_Y0 <- rbart_vi(y ~ . - ID, data = train_df, group.by = train_df$ID)
      matrix_Y0 <- predict(crossfit_Y0, newdata = test_df, group.by = test_df$ID)
      predict_Y0[test_idx] <- matrix_Y0
    }
  })
  
  
  #BART f1
  y <- df[,8]
  
  df_w_f1 <- as.data.frame(x)
  df_w_f1$y <- y
  df_w_f1$ID <- ID
  df_w_f1$lat <- lat
  df_w_f1$long <- long
  wend_f1 <- y ~ . - ID #- lat - long
  
  # split data into 10 folds
  folds <- createFolds(y, k = 10)
  # initialize placeholder for predictions
  predict_Y1 <- rep(NA, n)
  
  suppressWarnings({ 
    # crossfitting Y0
    for (fold in seq_along(folds)) {
      
      # this is the training data set
      train_idx <- setdiff(seq_len(n), folds[[fold]])
      # ith fold
      test_idx <- folds[[fold]]
      
      #dataframes for training and testing
      train_df <- cbind(x[train_idx, ], y = y[train_idx], ID = df_w_f1$ID[train_idx])
      
      test_df <- cbind(x[test_idx, ], y = y[test_idx], ID = df_w_f1$ID[test_idx])
      
      names(train_df) <- make.names(names(train_df), unique = TRUE)
      names(test_df) <- make.names(names(test_df), unique = TRUE)
      # bart model
      crossfit_Y1 <- rbart_vi(y ~ . - ID, data = train_df, group.by = train_df$ID)
      matrix_Y1 <- predict(crossfit_Y1, newdata = test_df, group.by = test_df$ID)
      predict_Y1[test_idx] <- matrix_Y1
    }
  })
  
  
  
  #BART g
  bart_d <-  df_w %>% 
    group_by (dat1.ID) %>%
    summarize_all(mean)
  
  y <- as.vector(bart_d[,7]$dat1.D)
  x <- data.frame(bart_d[,c(2:4, 12:ncol(bart_d))]) 
  
  # split data into 10 folds
  folds <- createFolds(y, k = 10)
  
  # initialize placeholder for predictions
  predict_D <- rep(NA, 64)
  
  # crossfitting D
  for (fold in seq_along(folds)) {
    
    # this is the training data set
    train_idx <- setdiff(seq_len(64), folds[[fold]])
    # ith fold
    test_idx <- folds[[fold]]
    
    # storing the predicted bart data into the placeholder vectors
    crossfit_bartD <- pbart(x.train = x[train_idx,], y.train = y[train_idx], x.test = x[test_idx,])
    predict_D[test_idx] <- crossfit_bartD$prob.test.mean
    
  }
  
  #to associate D with random effects, since pbart cannot take random effects directly
  df_fit_d <- data.frame(Key = seq(1, 64), D = predict_D)
  df_fit_d <- df_fit_d[rep(1:nrow(df_fit_d), times = 16), ]
  #this is a column of the IDs
  onecolumn_df <- data.frame(ID = df[,11])
  #Adds index columns for 1-to-1 matching
  df_fit_d$index <- ave(df_fit_d$Key, df_fit_d$Key, FUN = seq_along)
  onecolumn_df$index <- ave(onecolumn_df$ID, onecolumn_df$ID, FUN = seq_along)
  # merging
  onecolumn_df$Key <- onecolumn_df$ID
  onecolumn_df$ID <- NULL  # removing original ID column to avoid confusion
  new_dfit <- merge(onecolumn_df, df_fit_d, by = c("Key", "index"))
  names(new_dfit)[names(new_dfit) == "Key"] <- "ID"
  new_dfit <- new_dfit[order(new_dfit$index), c("ID", "D")]
  
  #this is to associate predict_D with its ID
  predict_D <- new_dfit$D
  
  
  # residuals
  R_Y0 <- df[,7] - predict_Y0
  R_Y1 <- df[,8] - predict_Y1
  R_D <- df[,6] - predict_D
  
  
  # calculate local mean
  R_D_m <- matrix(R_D, 32, 32)
  localR_D_m <- matrix(NA, 32, 32)
  for (i in 1:32) {
    for (j in 1:32) {
      # get surroundings (rook)
      # consider all cases
      if (i == 1) {
        if (j == 1) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j+1])
        }
        else if (j == 32) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i, j+1], R_D_m[i, j-1])
        }
      }
      else if (i == 32) {
        if (j == 1) {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j+1])
        }
        else if (j == 32) {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i-1, j], R_D_m[i, j+1], R_D_m[i, j-1])
        }      
      }
      else {
        if (j == 1) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], R_D_m[i, j+1])
        }
        else if (j == 32) {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], R_D_m[i, j-1])
        }
        else {
          neighbors <- c(R_D_m[i+1, j], R_D_m[i-1, j], 
                         R_D_m[i, j+1], R_D_m[i, j-1])
        }
      }
      localR_D_m[i,j] <- mean(na.omit(neighbors))   
    }
  }
  localR_D <- as.vector(localR_D_m)
  
  # regression
  t <- c(rep(0, n), rep(1, n))
  regress_DML <- lm(c(R_Y0, R_Y1) ~ t + c(R_D, R_D) + t*c(R_D, R_D))
  regress_robust_DML <- lm_robust(c(R_Y0, R_Y1) ~ t + c(R_D, R_D) + t*c(R_D, R_D))
  summary(regress_robust_DML)
  return(list(regress_DML, regress_robust_DML))
  
}

```



```{r}
library(ggplot2)

# data generating variables
ngrid <- 32 # grid size
n <- 32
m <- 4
p <- 5  # Number of covariates
range <- 0.3 # range
smoothness <- 2 # smoothness
tau2 <- 0.5 # Nugget Variance 
gam <- 3 # gamma
sigma2 <- 0.5

# number of samples
numSamples <- 120

#gamma
gammaOLS <- rep(NA, numSamples)
gammaDID <- rep(NA, numSamples)
gammaDML_nocross <- rep(NA, numSamples)
gammaDML_bypixel <- rep(NA, numSamples)
gammaDML_byblock <- rep(NA, numSamples)
gammaRE_nocross <- rep(NA, numSamples)
gammaRE_bypixel <- rep(NA, numSamples)
gammaRE_byblock <- rep(NA, numSamples)

# vector of SE
seOLS <- rep(NA, numSamples)
seDID <- rep(NA, numSamples)
seDML_nocross <- rep(NA, numSamples)
seDML_bypixel <- rep(NA, numSamples)
seDML_byblock <- rep(NA, numSamples)
seRE_nocross <- rep(NA, numSamples)
seRE_bypixel <- rep(NA, numSamples)
seRE_byblock <- rep(NA, numSamples)


for (i in 1:numSamples) {
  invisible(capture.output({
  suppressMessages({
    suppressWarnings({
      
      set.seed(919*i)
      
      # generate data      
      df1 <- genData(n, m, p, range, smoothness, tau2, gam, sigma2)
      
      # OLS
      OLS_robust <- OLS(df1, 32, 32)
      
      # DID
      DID_robust <- DID(df1, 32, 32)
      
      # DML without crossfitting
      DML_RE1 <- DML_nocross(df1, 32, 32)
      DML_nocross_reg <- DML_RE1[[1]]
      DML_nocross_robust <- DML_RE1[[2]]
      
      # DML with crossfitting
      DML_RE3 <- DML_bypixel(df1, 32, 32)
      DML_bypixel_reg <- DML_RE3[[1]]
      DML_bypixel_robust <- DML_RE3[[2]]
      
      DML_RE4 <- DML_byblock(df1, 32, 32)
      DML_byblock_reg <- DML_RE4[[1]]
      DML_byblock_robust <- DML_RE4[[2]]
      
      # DML with RE (no cross)
      DML_RE6 <- RE_nocross(df1, 32, 32)
      RE_nocross_reg <- DML_RE6[[1]]
      RE_nocross_robust <- DML_RE6[[2]]
      
      # DML withRE (with cross)
      DML_RE7 <- RE_bypixel(df1, 32, 32)
      RE_bypixel_reg <- DML_RE7[[1]]
      RE_bypixel_robust <- DML_RE7[[2]]
      
      DML_RE8 <- RE_byblock(df1, 32, 32)
      RE_byblock_reg <- DML_RE8[[1]]
      RE_byblock_robust <- DML_RE8[[2]]
      
      
      # calculate gammas
      gammaOLS[i] <- OLS_robust$coefficients[[7]]
      gammaDID[i] <- DID_robust$coefficients[[8]]
      gammaDML_nocross[i] <- DML_nocross_robust$coefficients[[5]]
      gammaDML_bypixel[i] <- DML_bypixel_robust$coefficients[[5]]
      gammaDML_byblock[i] <- DML_byblock_robust$coefficients[[4]]
      gammaRE_nocross[i] <- RE_nocross_robust$coefficients[[4]]
      gammaRE_bypixel[i] <- RE_bypixel_robust$coefficients[[4]]
      gammaRE_byblock[i] <- RE_byblock_robust$coefficients[[4]]
      
      # calculate SE
      seOLS[i] <- OLS_robust$std.error[[7]]
      seDID[i] <- DID_robust$std.error[[8]]
      seDML_nocross[i] <- DML_nocross_robust$std.error[[5]]
      seDML_bypixel[i] <- DML_bypixel_robust$std.error[[5]]
      seDML_byblock[i] <- DML_byblock_robust$std.error[[4]]
      seRE_nocross[i] <- RE_nocross_robust$std.error[[4]]
      seRE_bypixel[i] <- RE_bypixel_robust$std.error[[4]]
      seRE_byblock[i] <- RE_byblock_robust$std.error[[4]]
      
        
    })
  })
  }))
}

# expected value for gamma
meanGamma <- rep(NA, 8) # meanGamma is my predictor of gamma for each method
meanGamma[1] <- mean(na.omit(gammaOLS))
meanGamma[2] <- mean(na.omit(gammaDID))
meanGamma[3] <- mean(na.omit(gammaDML_nocross))
meanGamma[4] <- mean(na.omit(gammaDML_bypixel))
meanGamma[5] <- mean(na.omit(gammaDML_byblock))
meanGamma[6] <- mean(na.omit(gammaRE_nocross))
meanGamma[7] <- mean(na.omit(gammaRE_bypixel))
meanGamma[8] <- mean(na.omit(gammaRE_byblock))

# calculate bias for gamma
biasGamma <- rep(NA, 8)
biasGamma[1] <- mean(meanGamma[1] - gam)
biasGamma[2] <- mean(meanGamma[2] - gam)
biasGamma[3] <- mean(meanGamma[3] - gam)
biasGamma[4] <- mean(meanGamma[4] - gam)
biasGamma[5] <- mean(meanGamma[5] - gam)
biasGamma[6] <- mean(meanGamma[6] - gam)
biasGamma[7] <- mean(meanGamma[7] - gam)
biasGamma[8] <- mean(meanGamma[8] - gam)

# calculate relative bias for gamma (bias / gamma)
relBiasGamma <- rep(NA, 8)
relBiasGamma[1] <- biasGamma[1] / gam
relBiasGamma[2] <- biasGamma[2] / gam
relBiasGamma[3] <- biasGamma[3] / gam
relBiasGamma[4] <- biasGamma[4] / gam
relBiasGamma[5] <- biasGamma[5] / gam
relBiasGamma[6] <- biasGamma[6] / gam
relBiasGamma[7] <- biasGamma[7] / gam
relBiasGamma[8] <- biasGamma[8] / gam

# calculate MSE for gamma
mseGamma <- rep(NA, 8)
mseGamma[1] <- mean((na.omit(gammaOLS) - gam)**2)
mseGamma[2] <- mean((na.omit(gammaDID) - gam)**2)
mseGamma[3] <- mean((na.omit(gammaDML_nocross) - gam)**2)
mseGamma[4] <- mean((na.omit(gammaDML_bypixel) - gam)**2)
mseGamma[5] <- mean((na.omit(gammaDML_byblock) - gam) **2)
mseGamma[6] <- mean((na.omit(gammaRE_nocross) - gam)**2)
mseGamma[7] <- mean((na.omit(gammaRE_bypixel) - gam)**2)
mseGamma[8] <- mean((na.omit(gammaRE_byblock) - gam)**2)


# calculate SE for gamma 
seGamma <- rep(NA, 8) # seGamma is my predictor of SE for each method
seGamma[1] <- mean(na.omit(seOLS))
seGamma[2] <- mean(na.omit(seDID))
seGamma[3] <- mean(na.omit(seDML_nocross))
seGamma[4] <- mean(na.omit(seDML_bypixel))
seGamma[5] <- mean(na.omit(seDML_byblock))
seGamma[6] <- mean(na.omit(seRE_nocross))
seGamma[7] <- mean(na.omit(seRE_bypixel))
seGamma[8] <- mean(na.omit(seRE_byblock))


# expected confidence interval length (95%)
lengthCI <- rep(NA, 8)
lengthCI[1] <- 2 * 1.96 * seGamma[1] 
lengthCI[2] <- 2 * 1.96 * seGamma[2] 
lengthCI[3] <- 2 * 1.96 * seGamma[3]
lengthCI[4] <- 2 * 1.96 * seGamma[4] 
lengthCI[5] <- 2 * 1.96 * seGamma[5]
lengthCI[6] <- 2 * 1.96 * seGamma[6]
lengthCI[7] <- 2 * 1.96 * seGamma[7]
lengthCI[8] <- 2 * 1.96 * seGamma[8]


# calculate coverage (% of each gamma predicted within individual confidence interval (95%))
# note: this is not using the average confidence interval length calculated above
cvgGamma <- rep(NA, 8)
cvgGamma[1] <- mean((gam <= gammaOLS + 1.96*seOLS) & (gam >= gammaOLS - 1.96*seOLS))
cvgGamma[2] <- mean((gam <= gammaDID + 1.96*seDID) & (gam >= gammaDID - 1.96*seDID))
cvgGamma[3] <- mean((gam <= gammaDML_nocross + 1.96*seDML_nocross) & (gam >= gammaDML_nocross - 1.96*seDML_nocross))
cvgGamma[4] <- mean((gam <= gammaDML_bypixel + 1.96*seDML_bypixel) & (gam >= gammaDML_bypixel - 1.96*seDML_bypixel))
cvgGamma[5] <- mean((gam <= gammaDML_byblock + 1.96*seDML_byblock) & (gam >= gammaDML_byblock - 1.96*seDML_byblock))
cvgGamma[6] <- mean((gam <= gammaRE_nocross + 1.96*seRE_nocross) & (gam >= gammaRE_nocross - 1.96*seRE_nocross))
cvgGamma[7] <- mean((gam <= gammaRE_bypixel + 1.96 * seRE_bypixel) & (gam >= gammaRE_bypixel - 1.96*seRE_bypixel))
cvgGamma[8] <- mean((gam <= gammaRE_byblock + 1.96*seRE_byblock) & (gam >= gammaRE_byblock - 1.96*seRE_byblock))

#skipping power, can add it in later


# Combine all gamma differences into a data frame
method <- factor(rep(c("OLS", "DID", "DML no cross", "DML by pixel", "DML by block", 
                       "RE no cross", "RE by pixel", "RE by block"),
                     each = length(gammaOLS)),
                 levels = c("OLS", "DID", "DML no cross", "DML by pixel", "DML by block", 
                       "RE no cross", "RE by pixel", "RE by block"))

df <- data.frame(
  method = method,
  value = c(gammaOLS - gam,
            gammaDID - gam,
            gammaDML_nocross - gam,
            gammaDML_bypixel - gam,
            gammaDML_byblock - gam,
            gammaRE_nocross - gam,
            gammaRE_bypixel - gam, 
            gammaRE_byblock - gam)
)

# Create plot
box <- ggplot(df, aes(x = method, y = value)) + geom_boxplot() +
  labs(title = "Bias in Treatment Effect Predictor with Random Effects",
       y = expression(hat(gamma) - gamma),
       x = "") + theme_bw() +
  theme(axis.text.x = element_text (size = 8),
        axis.text.y = element_text(size = 12),
        axis.title.y = element_text(size = 20),
        plot.title = element_text(size = 20)) + 
  geom_hline(yintercept = 0, linetype = "dashed", color = "black")
results <- data.frame(meanGamma, biasGamma, relBiasGamma, mseGamma, seGamma, lengthCI, cvgGamma)

```


Store results (input smoothness and tau2 here)
```{r}
initialConditions <- c(ngrid = ngrid, p = p, range = range, smoothness = smoothness, tau2 = tau2, gam = gam)
results <- data.frame(meanGamma, biasGamma, relBiasGamma, mseGamma, seGamma, lengthCI, cvgGamma)
boxplot <- box

```


```{r}


# save as an R data file
#save(initialConditions, results, boxplot, numSamples, gammaOLS, gammaDID, gammaDML_noCross, gammaDML_cross, gammaDML_W_noCross, gammaDML_W_cross, seOLS, seDID, seDML_noCross, seDML_cross, seDML_W_cross, seDML_W_noCross, file = "both-methods-RE-includes-LatLong_250samps.RData")

```
